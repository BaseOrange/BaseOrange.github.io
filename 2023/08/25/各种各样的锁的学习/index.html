<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/o.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/o.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/o.png">
  <link rel="mask-icon" href="/images/o.svg" color="#222">
  <meta name="google-site-verification" content="JyJm6tHJ1q5mhbqwbRl4KEUE_ms1dc_9MJ0G0GIHnq8">
  <meta name="baidu-site-verification" content="codeva-tXW0RgD5OZ">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"log.660066.xyz","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12,"onmobile":false,"dimmer":true},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-1}},"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="各种各样的锁的学习">
<meta property="og:type" content="article">
<meta property="og:title" content="各种各样的锁的学习">
<meta property="og:url" content="https://log.660066.xyz/2023/08/25/%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E9%94%81%E7%9A%84%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="大橙子">
<meta property="og:description" content="各种各样的锁的学习">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://log.660066.xyz/2023/08/25/%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E9%94%81%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20230904173348885.png">
<meta property="article:published_time" content="2023-08-25T02:11:09.000Z">
<meta property="article:modified_time" content="2024-11-17T12:46:27.000Z">
<meta property="article:author" content="BigOrange">
<meta property="article:tag" content="锁">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://log.660066.xyz/2023/08/25/%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E9%94%81%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20230904173348885.png">


<link rel="canonical" href="https://log.660066.xyz/2023/08/25/%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E9%94%81%E7%9A%84%E5%AD%A6%E4%B9%A0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://log.660066.xyz/2023/08/25/%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E9%94%81%E7%9A%84%E5%AD%A6%E4%B9%A0/","path":"2023/08/25/各种各样的锁的学习/","title":"各种各样的锁的学习"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>各种各样的锁的学习 | 大橙子</title>
  







  <script defer data-domain="660066.xyz" src="https://plausible.io/js/script.js"></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="大橙子" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="大橙子" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">大橙子</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-工具箱"><a href="/tools/" rel="section"><i class="fa fa-flask fa-fw"></i>工具箱</a></li><li class="menu-item menu-item-友情链接"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友情链接</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%8D%81%E4%BA%94%E6%8A%8A%E9%94%81"><span class="nav-text">一、十五把锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81ReentrantLock"><span class="nav-text">二、ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E4%BB%8B%E7%BB%8D"><span class="nav-text">2.1 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-text">2.2 常用方法：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E5%9C%BA%E6%99%AF"><span class="nav-text">2.3 场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81Synchronized"><span class="nav-text">三、Synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E4%BB%8B%E7%BB%8D"><span class="nav-text">3.1 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">3.2 使用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="nav-text">3.2.1 修饰方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-text">3.2.2 修饰代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-text">3.2.3 修饰静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4-%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="nav-text">3.2.4 修饰类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E5%9C%BA%E6%99%AF"><span class="nav-text">3.3 场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81ReentrantReadWriteLock"><span class="nav-text">四、ReentrantReadWriteLock</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E4%BB%8B%E7%BB%8D"><span class="nav-text">4.1 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">4.2 使用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E5%9C%BA%E6%99%AF"><span class="nav-text">4.3 场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81Atomic-%E5%85%A8%E5%AE%B6%E6%A1%B6"><span class="nav-text">五、Atomic 全家桶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E4%BB%8B%E7%BB%8D"><span class="nav-text">5.1 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">5.2 使用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E5%9C%BA%E6%99%AF"><span class="nav-text">5.3 场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81Concurrent%E5%85%A8%E5%AE%B6%E6%A1%B6"><span class="nav-text">六、Concurrent全家桶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E4%BB%8B%E7%BB%8D"><span class="nav-text">6.1 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">6.2 使用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E5%9C%BA%E6%99%AF"><span class="nav-text">6.3 场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E9%87%8D%E7%82%B9%E5%88%86%E5%B8%83%E5%BC%8F%E5%9C%BA%E6%99%AFredisson%E5%92%8CZK%E9%94%81"><span class="nav-text">七、重点分布式场景redisson和ZK锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-Redisson"><span class="nav-text">7.1 Redisson</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-1-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%88Reentrant-Lock%EF%BC%89"><span class="nav-text">7.1.1 可重入锁（Reentrant Lock）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-2-%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%88Fair-Lock%EF%BC%89"><span class="nav-text">7.1.2 公平锁（Fair Lock）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-3-%E8%81%94%E9%94%81%EF%BC%88MultiLock%EF%BC%89"><span class="nav-text">7.1.3 联锁（MultiLock）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-4-%E7%BA%A2%E9%94%81%EF%BC%88RedLock%EF%BC%89"><span class="nav-text">7.1.4 红锁（RedLock）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-5-%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%88ReadWriteLock%EF%BC%89"><span class="nav-text">7.1.5 读写锁（ReadWriteLock）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-6-%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88Semaphore%EF%BC%89"><span class="nav-text">7.1.6 信号量（Semaphore）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-7-%E5%8F%AF%E8%BF%87%E6%9C%9F%E6%80%A7%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88PermitExpirableSemaphore%EF%BC%89"><span class="nav-text">7.1.7 可过期性信号量（PermitExpirableSemaphore）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-8-%E9%97%AD%E9%94%81%EF%BC%88CountDownLatch%EF%BC%89"><span class="nav-text">7.1.8 闭锁（CountDownLatch）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-Zookeeper"><span class="nav-text">7.2 Zookeeper</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%88Shared-Reentrant-Lock%EF%BC%89"><span class="nav-text">7.2.1 可重入锁（Shared Reentrant Lock）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-2-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%88Shared-Lock%EF%BC%89"><span class="nav-text">7.2.2 不可重入锁（Shared Lock）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-3-%E5%8F%AF%E9%87%8D%E5%85%A5%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%88Shared-Reentrant-Read-Write-Lock%EF%BC%89"><span class="nav-text">7.2.3 可重入读写锁（Shared Reentrant Read Write Lock）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-4-%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88Shared-Semaphore%EF%BC%89"><span class="nav-text">7.2.4 信号量（Shared Semaphore）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-5-%E5%A4%9A%E9%94%81%E5%AF%B9%E8%B1%A1%EF%BC%88Multi-Shared-Lock%EF%BC%89"><span class="nav-text">7.2.5 多锁对象（Multi Shared Lock）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-6-%E5%AE%8C%E6%95%B4%E9%94%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">7.2.6 完整锁示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-text">八、总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E6%80%9D%E8%80%83"><span class="nav-text">九、思考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">BigOrange</p>
  <div class="site-description" itemprop="description">新的斗争开始了<br/>A new struggle has begun</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://log.660066.xyz/2023/08/25/%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E9%94%81%E7%9A%84%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="BigOrange">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大橙子">
      <meta itemprop="description" content="新的斗争开始了<br/>A new struggle has begun">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="各种各样的锁的学习 | 大橙子">
      <meta itemprop="description" content="各种各样的锁的学习">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          各种各样的锁的学习
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-25 10:11:09" itemprop="dateCreated datePublished" datetime="2023-08-25T10:11:09+08:00">2023-08-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-17 20:46:27" itemprop="dateModified" datetime="2024-11-17T20:46:27+08:00">2024-11-17</time>
    </span>

  
</div>

            <div class="post-description">各种各样的锁的学习</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>人是生而自由的，但却无往不在枷锁之中。自以为是其他一切的主人的人，反而比其他一切更是奴隶。 ——卢梭</p>
<h1 id="一、十五把锁"><a href="#一、十五把锁" class="headerlink" title="一、十五把锁"></a>一、十五把锁</h1><table>
<thead>
<tr>
<th>序号</th>
<th>十五把锁</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>以</td>
<td>乐观锁</td>
<td>操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</td>
</tr>
<tr>
<td>而</td>
<td>悲观锁</td>
<td>操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。</td>
</tr>
<tr>
<td>散</td>
<td>自旋锁</td>
<td>当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁，等待的机制被称为自旋锁。</td>
</tr>
<tr>
<td>思</td>
<td>重入锁</td>
<td>当一个线程成功获取到重入锁后，如果再次访问该临界区，该线程可以再次获取锁，而不会对自己产生互斥行为。</td>
</tr>
<tr>
<td>无</td>
<td>读写锁</td>
<td>一种允许多个读线程同时访问共享资源，但只允许一个写线程访问共享资源的锁机制。</td>
</tr>
<tr>
<td>溜</td>
<td>公平锁</td>
<td>多个线程按照申请锁的顺序来获取锁。</td>
</tr>
<tr>
<td>期</td>
<td>非公平锁</td>
<td>多个线程获取锁的顺序并不是按照申请锁的顺序。</td>
</tr>
<tr>
<td>吧</td>
<td>共享锁</td>
<td>当一个线程获取读锁时，其他线程可以同时获取读锁，但只有一个线程可以获取写锁。当其他线程都释放了读锁后，写锁才会被释放</td>
</tr>
<tr>
<td>酒</td>
<td>独占锁</td>
<td>只能被一个线程获取，并且只允许一个线程拥有该锁。当一个线程获取了独占锁时，其他线程必须等待该线程释放锁后才能获取该锁。</td>
</tr>
<tr>
<td>是</td>
<td>重量级锁</td>
<td>基于操作系统的互斥量（Mutex Lock）而实现的锁，会导致进程在用户态和内核态之间切换，相对开销较大</td>
</tr>
<tr>
<td>是以</td>
<td>轻量级锁</td>
<td>在没有多线程竞争的前提下，减少重量级锁的使用以提高系统性能。轻量级锁适用于线程交替执行同步代码块的情况（既互斥操作），如果同一时刻与多个线程访问同一个锁，则将会导致轻量级锁膨胀为重量级锁。</td>
</tr>
<tr>
<td>是而</td>
<td>偏向锁</td>
<td>种针对多线程并发访问的锁机制，它主要解决的是在没有竞争的情况下如何提高性能的问题。让一个线程多次获得锁，减少其他线程获取锁的开销。有线程竞争的情况下，偏向锁会膨胀为轻量级锁，可能会导致性能下降。</td>
</tr>
<tr>
<td>是散</td>
<td>分段锁</td>
<td>将共享资源分割成多个段，并为每段都提供一把锁。解决多线程并发访问的锁机制，它主要解决的是在没有竞争的情况下如何提高性能的问题。</td>
</tr>
<tr>
<td>是思</td>
<td>互斥锁</td>
<td>只能被一个线程获取，并且只允许一个线程拥有该锁。当一个线程获取了互斥锁时，其他线程必须等待该线程释放锁后才能获取该锁。</td>
</tr>
<tr>
<td>是无</td>
<td>同步锁</td>
<td>保证在同一时刻只有一个线程可以执行某个代码块。当一个线程进入同步代码块时，它会获取该锁，执行完代码块后释放该锁。其他线程必须等待该线程释放锁后才能进入该代码块。</td>
</tr>
</tbody></table>
<p>java里就是：</p>
<p><strong>ReentrantLock，Synchronieed，ReentrantReadWriteLock，Atomic 全家桶，Concurrent全家桶</strong></p>
<h1 id="二、ReentrantLock"><a href="#二、ReentrantLock" class="headerlink" title="二、ReentrantLock"></a>二、ReentrantLock</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p>ReentrantLock是一个互斥的可重入锁。互斥的意思就是<strong>排他，独占</strong>，<strong>只能一个线程获取到锁</strong>。可重入的意思就是<strong>单个线程可以多次重复获取锁</strong>。</p>
<p>实现了<strong>悲观锁、重入锁、独占锁、非公平锁、互斥锁</strong></p>
<h2 id="2-2-常用方法："><a href="#2-2-常用方法：" class="headerlink" title="2.2 常用方法："></a>2.2 常用方法：</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>异常</th>
</tr>
</thead>
<tbody><tr>
<td>lock()</td>
<td>一直阻塞获取锁，直到成功</td>
<td>无</td>
</tr>
<tr>
<td>lockInterruptibly()</td>
<td>尝试获取锁，直到获取锁或者线程被中断</td>
<td>InterruptedException</td>
</tr>
<tr>
<td>tryLock()</td>
<td>尝试获取空闲的锁，获取成功返回true，获取失败返回flase，不会阻塞，立即返回</td>
<td>无</td>
</tr>
<tr>
<td>tryLock(long time, TimeUnit unit)</td>
<td>尝试在TIME时间内获取空闲的锁，在等待时间内可以被中断</td>
<td>InterruptedException</td>
</tr>
<tr>
<td>unLock()</td>
<td>释放锁</td>
<td>无</td>
</tr>
<tr>
<td>newCondition()</td>
<td>返回当前所得一个condition实例，可以唤醒或者等待线程</td>
<td>无</td>
</tr>
</tbody></table>
<h2 id="2-3-场景"><a href="#2-3-场景" class="headerlink" title="2.3 场景"></a>2.3 场景</h2><p><strong>递归嵌套</strong>的业务场景中，例如<strong>一棵树型的业务逻辑，方法有嵌套和调用</strong>，这时候我从外层加锁后，在递归遍历多次，每次都要是同一把锁，并且递归到其他层级时锁还不能失效。这个时候就可以使用重入锁了。江湖上还有个花名，叫<strong>递归锁</strong>。</p>
<h1 id="三、Synchronized"><a href="#三、Synchronized" class="headerlink" title="三、Synchronized"></a>三、Synchronized</h1><h2 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h2><p>Synchronized是<strong>悲观锁，默认是偏向锁</strong>，<strong>解锁失败后会升级为轻量级锁</strong>，当竞争继续加剧，进入<strong>CAS自旋10次后会升级为重量级锁</strong>。</p>
<p>实现了<strong>悲观锁、重入锁（用关键字修饰方法或代码段时）、独占锁，非公平锁、轻量级锁、重量级锁、偏向锁、同步锁</strong></p>
<h2 id="3-2-使用方法"><a href="#3-2-使用方法" class="headerlink" title="3.2 使用方法"></a>3.2 使用方法</h2><h3 id="3-2-1-修饰方法"><a href="#3-2-1-修饰方法" class="headerlink" title="3.2.1 修饰方法"></a>3.2.1 修饰方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-修饰代码块"><a href="#3-2-2-修饰代码块" class="headerlink" title="3.2.2 修饰代码块"></a>3.2.2 修饰代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lockObject) &#123;</span><br><span class="line">        <span class="comment">// 临界区代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-修饰静态方法"><a href="#3-2-3-修饰静态方法" class="headerlink" title="3.2.3 修饰静态方法"></a>3.2.3 修饰静态方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">someStaticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-4-修饰类"><a href="#3-2-4-修饰类" class="headerlink" title="3.2.4 修饰类"></a>3.2.4 修饰类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(MyClass.class) &#123;</span><br><span class="line">            <span class="comment">// 同步代码块</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 同步方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-场景"><a href="#3-3-场景" class="headerlink" title="3.3 场景"></a>3.3 场景</h2><p><strong>多个线程访问共享变量，为了保证其原子性</strong>就可以使用 synchronized 。一个典型的业务场景是<strong>银行转账操作</strong>。假设有多个用户在同时进行转账操作，需要确保转账过程的原子性和数据的一致性，避免出现重复转账或者转账金额错误的情况。在这种情况下，<strong>可以使用 synchronized 关键字来实现同步访问。</strong></p>
<h1 id="四、ReentrantReadWriteLock"><a href="#四、ReentrantReadWriteLock" class="headerlink" title="四、ReentrantReadWriteLock"></a>四、ReentrantReadWriteLock</h1><h2 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h2><p>ReentrantReadWriteLock是Java提供的<strong>读写锁</strong>，它<strong>支持多个线程同时读取共享数据，但只允许一个线程进行写操作</strong>。</p>
<p>实现了<strong>读写锁、共享锁</strong>。</p>
<h2 id="4-2-使用方法"><a href="#4-2-使用方法" class="headerlink" title="4.2 使用方法"></a>4.2 使用方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>readLock()</td>
<td>获取读锁</td>
</tr>
<tr>
<td>writeLock()</td>
<td>获取写锁</td>
</tr>
<tr>
<td>readLock().lock()</td>
<td>获取读锁并加锁</td>
</tr>
<tr>
<td>writeLock().lock()</td>
<td>获取写锁并加锁</td>
</tr>
<tr>
<td>readLock().unLock()</td>
<td>释放读锁</td>
</tr>
<tr>
<td>writeLock().unLock()</td>
<td>释放写锁</td>
</tr>
<tr>
<td>newCondition()</td>
<td>创建与锁关联的condition实例，可以唤醒或者等待线程</td>
</tr>
</tbody></table>
<h2 id="4-3-场景"><a href="#4-3-场景" class="headerlink" title="4.3 场景"></a>4.3 场景</h2><p>读写锁应用在<strong>读多写少</strong>的情况下。读取时不涉及数据修改，写入时需要互斥操作。现在基本所有的号称<strong>效率高的准实时数据库都有实现读写锁的算法</strong>。</p>
<h1 id="五、Atomic-全家桶"><a href="#五、Atomic-全家桶" class="headerlink" title="五、Atomic 全家桶"></a>五、Atomic 全家桶</h1><h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><p>Atomic全家桶 我们以AtomicInteger为例。他的特点是<strong>实现了CAS算法</strong>，同时解决了ABA问题保证原子性。还实现了<strong>自旋锁的CLHLock算法</strong>，用于<strong>CAS比较失败后自旋等待</strong>。</p>
<p>它实现了<strong>乐观锁、自旋锁、轻量级锁</strong></p>
<h2 id="5-2-使用方法"><a href="#5-2-使用方法" class="headerlink" title="5.2 使用方法"></a>5.2 使用方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>get()</td>
<td>获取当前AtomicInteger对象的值</td>
</tr>
<tr>
<td>set(int newValue)</td>
<td>将AtomicInteger对象的值设置为指定的新值</td>
</tr>
<tr>
<td>getAndSet(int newValue)</td>
<td>将AtomicInteger对象的值设置为指定的新值，并返回旧值</td>
</tr>
<tr>
<td>incrementAndGet()</td>
<td>将AtomicInteger对象的值**+**1，并返回递增后的新值</td>
</tr>
<tr>
<td>decrementAndGet()</td>
<td>将AtomicInteger对象的值**-**1，并返回递减后的新值</td>
</tr>
<tr>
<td>getAndIncrement()</td>
<td>先获取AtomicInteger对象的当前值，然后**+**1，并返回获取的旧值</td>
</tr>
<tr>
<td>getAndDecrement()</td>
<td>先获取AtomicInteger对象的当前值，然后**-**1，并返回获取的旧值</td>
</tr>
<tr>
<td>addAndGet(int delta)</td>
<td>将指定值加到AtomicInteger对象的值，返回相加后结果</td>
</tr>
<tr>
<td>getAndAdd(int delta)</td>
<td>先获取AtomicInteger对象的当前值，然后将指定值加到AtomicInteger对象的值，返回获取的旧值</td>
</tr>
</tbody></table>
<h2 id="5-3-场景"><a href="#5-3-场景" class="headerlink" title="5.3 场景"></a>5.3 场景</h2><p>用来做<strong>计数器</strong>非常合适，再有就是<strong>线程通讯，数据共享</strong>。</p>
<h1 id="六、Concurrent全家桶"><a href="#六、Concurrent全家桶" class="headerlink" title="六、Concurrent全家桶"></a>六、Concurrent全家桶</h1><h2 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 介绍"></a>6.1 介绍</h2><p>Concurrent全家桶我们以ConcurrentHashMap为代表。它实现了<strong>分段锁算法</strong>（Segmented Locking）的策略，将整个数据结构<strong>划分成多个Segments</strong>，<strong>每个段都拥有独立的锁</strong>。</p>
<h2 id="6-2-使用方法"><a href="#6-2-使用方法" class="headerlink" title="6.2 使用方法"></a>6.2 使用方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>clear()</td>
<td>移除所有关系</td>
</tr>
<tr>
<td>containsKey(Object value)</td>
<td>检查指定对象是否都为表中的健</td>
</tr>
<tr>
<td>containsValue(Object value)</td>
<td>如果此映射将一个或多个键映射到指定值，返回true</td>
</tr>
<tr>
<td>elements()</td>
<td>返回此表值的枚举</td>
</tr>
<tr>
<td>entrySet()</td>
<td>返回此映射所包含的映射关系Set视图</td>
</tr>
<tr>
<td>get()</td>
<td>返回指定键映射到的值，如果此映射不包含该键的映射关系，则返回null</td>
</tr>
<tr>
<td>isEmpty()</td>
<td>此映射不包含键值则返回true</td>
</tr>
<tr>
<td>keys()</td>
<td>返回此表中健的枚举</td>
</tr>
<tr>
<td>put(K key, V value)</td>
<td>指定将键映射到此表中的指定值</td>
</tr>
<tr>
<td>putAll(Map&lt;? extends k, ? extends v&gt; m)</td>
<td>将指定映射中所有的映射关系复制到此映射中</td>
</tr>
<tr>
<td>size()</td>
<td>返回此映射中的键值映射关系数</td>
</tr>
<tr>
<td>remove(Ob)</td>
<td>将键从此映射中移除</td>
</tr>
<tr>
<td>replace(Kkey, V value)</td>
<td>只有目前将键的条目映射到给定值时，才替换该键的条目</td>
</tr>
</tbody></table>
<h2 id="6-3-场景"><a href="#6-3-场景" class="headerlink" title="6.3 场景"></a>6.3 场景</h2><p>在java中ConcurrentHashMap，就是将数据<strong>分为16段</strong>，每一段都有单独的锁，并且处于不同锁段的数据互不干扰，以此来提升锁的性能。</p>
<p>比如在秒杀扣库存的场景中，现在的库存中有2000个商品，用户可以秒杀。为了防止出现超卖的情况，通常情况下，可以对库存加锁。如果有1W的用户竞争同一把锁，显然系统吞吐量会非常低。为了提升系统性能，我们可以将库存分段，比如：分为100段，这样每段就有20个商品可以参与秒杀。在秒杀的过程中，先把用户id获取hash值，然后除以100取模。模为1的用户访问第1段库存，模为2的用户访问第2段库存，模为3的用户访问第3段库存，后面以此类推，到最后模为100的用户访问第100段库存。如此一来，在多线程环境中，可以大大地减少锁的冲突。</p>
<h1 id="七、重点分布式场景redisson和ZK锁"><a href="#七、重点分布式场景redisson和ZK锁" class="headerlink" title="七、重点分布式场景redisson和ZK锁"></a>七、重点分布式场景redisson和ZK锁</h1><h2 id="7-1-Redisson"><a href="#7-1-Redisson" class="headerlink" title="7.1 Redisson"></a>7.1 Redisson</h2><p>我们日常开发中用用的最多的场景还是<strong>分布式锁</strong>。提到分布式锁就不可回避Redisson。WHY？他就是权威好用。使用场景最多没有之一。Redisson官方一共提供了<strong>8把锁</strong>。</p>
<h3 id="7-1-1-可重入锁（Reentrant-Lock）"><a href="#7-1-1-可重入锁（Reentrant-Lock）" class="headerlink" title="7.1.1 可重入锁（Reentrant Lock）"></a>7.1.1 可重入锁（Reentrant Lock）</h3><p>基于Redis的Redisson分布式可重入锁RLock Java对象实现了java.util.concurrent.locks.Lock接口。同时还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="comment">// connects to 127.0.0.1:6379 by default</span></span><br><span class="line">       <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create();</span><br><span class="line">       </span><br><span class="line">       <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">       lock.lock(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="type">RLock</span> <span class="variable">lock1</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">               lock1.lock();</span><br><span class="line">               lock1.unlock();</span><br><span class="line">           &#125;;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       t.start();</span><br><span class="line">       t.join();</span><br><span class="line"></span><br><span class="line">       redisson.shutdown();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>如果负责储存这个分布式锁的Redisson节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现<strong>锁死</strong>的状态。为了避免这种情况的发生，<strong>Redisson内部提供了一个监控锁的看门狗</strong>，它的作用是在Redisson实例被关闭前，不断地延长锁的有效期。默认情况下，看门狗的检查锁的超时时间是30秒钟，也可以通过修改Config.lockWatchdogTimeout来另行指定。</p>
<p>另外Redisson还通过加锁的方法提供了leaseTime的参数来指定加锁的时间。超过这个时间后锁便自动解开了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁以后10秒钟自动解锁</span></span><br><span class="line"><span class="comment">// 无需调用unlock方法手动解锁</span></span><br><span class="line">lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> lock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">if</span> (res) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Redisson同时还为分布式锁提供了<strong>异步执行</strong>的相关方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">lock.lockAsync();</span><br><span class="line">lock.lockAsync(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">Future&lt;Boolean&gt; res = lock.tryLockAsync(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>RLock对象完全符合Java的Lock规范。也就是说只有拥有锁的进程才能解锁，其他进程解锁则会抛出IllegalMonitorStateException错误。但是如果<strong>遇到需要其他进程也能解锁的情况，请使用分布式信号量Semaphore 对象.</strong></p>
<h3 id="7-1-2-公平锁（Fair-Lock）"><a href="#7-1-2-公平锁（Fair-Lock）" class="headerlink" title="7.1.2 公平锁（Fair Lock）"></a>7.1.2 公平锁（Fair Lock）</h3><p>基于Redis的Redisson分布式可重入公平锁也是实现了java.util.concurrent.locks.Lock接口的一种RLock对象。同时还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。它保证了<strong>当多个Redisson客户端线程同时请求加锁时，优先分配给先发出请求的线程</strong>。所有<strong>请求线程会在一个队列中排队，当某个线程出现宕机时，Redisson会等待5秒后继续下一个线程，也就是说如果前面有5个线程都处于等待状态，那么后面的线程会等待至少25秒。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// connects to 127.0.0.1:6379 by default</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create();</span><br><span class="line">        </span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getFairLock(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Thread&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            threads.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">            thread.join(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>同样也有看门狗机制来防止死锁。另外Redisson还通过加锁的方法提供了leaseTime的参数来指定加锁的时间。超过这个时间后锁便自动解开了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10秒钟以后自动解锁</span></span><br><span class="line"><span class="comment">// 无需调用unlock方法手动解锁</span></span><br><span class="line">fairLock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> fairLock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">...</span><br><span class="line">fairLock.unlock();</span><br></pre></td></tr></table></figure>



<p>Redisson同时还为分布式可重入公平锁提供了异步执行的相关方法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> redisson.getFairLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">fairLock.lockAsync();</span><br><span class="line">fairLock.lockAsync(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">Future&lt;Boolean&gt; res = fairLock.tryLockAsync(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<h3 id="7-1-3-联锁（MultiLock）"><a href="#7-1-3-联锁（MultiLock）" class="headerlink" title="7.1.3 联锁（MultiLock）"></a>7.1.3 联锁（MultiLock）</h3><p>基于Redis的Redisson分布式联锁RedissonMultiLock对象可以将多个RLock对象关联为一个联锁，<strong>每个RLock对象实例可以来自于不同的Redisson实例</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// connects to 127.0.0.1:6379 by default</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">client</span> <span class="operator">=</span> Redisson.create();</span><br><span class="line">        <span class="comment">// 同时加锁：lock1 lock2 lock3 所有的锁都上锁成功才算成功。</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock1</span> <span class="operator">=</span> client.getLock(<span class="string">&quot;lock1&quot;</span>);</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock2</span> <span class="operator">=</span> client.getLock(<span class="string">&quot;lock2&quot;</span>);</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock3</span> <span class="operator">=</span> client.getLock(<span class="string">&quot;lock3&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">RedissonMultiLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonMultiLock</span>(lock1, lock2, lock3);</span><br><span class="line">                lock.lock();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">        t.join(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">RedissonMultiLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonMultiLock</span>(lock1, lock2, lock3);</span><br><span class="line">        lock.lock();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>同样也有看门狗机制来防止死锁。另外Redisson还通过加锁的方法提供了leaseTime的参数来指定加锁的时间。超过这个时间后锁便自动解开了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RedissonMultiLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonMultiLock</span>(lock1, lock2, lock3);</span><br><span class="line"><span class="comment">// 给lock1，lock2，lock3加锁，如果没有手动解开的话，10秒钟后将会自动解开</span></span><br><span class="line">lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为加锁等待100秒时间，并在加锁成功10秒钟后自动解开</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> lock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>

<h3 id="7-1-4-红锁（RedLock）"><a href="#7-1-4-红锁（RedLock）" class="headerlink" title="7.1.4 红锁（RedLock）"></a>7.1.4 红锁（RedLock）</h3><p>基于Redis的Redisson红锁RedissonRedLock对象实现了Redlock介绍的加锁算法。该对象也可以用来将多个RLock对象关联为一个红锁，每个RLock对象实例可以来自于不同的Redisson实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock1</span> <span class="operator">=</span> redissonInstance1.getLock(<span class="string">&quot;lock1&quot;</span>);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock2</span> <span class="operator">=</span> redissonInstance2.getLock(<span class="string">&quot;lock2&quot;</span>);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock3</span> <span class="operator">=</span> redissonInstance3.getLock(<span class="string">&quot;lock3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">RedissonRedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonRedLock</span>(lock1, lock2, lock3);</span><br><span class="line"><span class="comment">// 同时加锁：lock1 lock2 lock3</span></span><br><span class="line"><span class="comment">// 红锁在大部分节点上加锁成功就算成功。</span></span><br><span class="line">lock.lock();</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br><span class="line">。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// connects to 127.0.0.1:6379 by default</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">client1</span> <span class="operator">=</span> Redisson.create();</span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">client2</span> <span class="operator">=</span> Redisson.create();</span><br><span class="line">        </span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock1</span> <span class="operator">=</span> client1.getLock(<span class="string">&quot;lock1&quot;</span>);</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock2</span> <span class="operator">=</span> client1.getLock(<span class="string">&quot;lock2&quot;</span>);</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock3</span> <span class="operator">=</span> client2.getLock(<span class="string">&quot;lock3&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                lock3.lock();</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">RedissonMultiLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonRedLock</span>(lock1, lock2, lock3);</span><br><span class="line">                lock.lock();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">        t.join(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        lock3.forceUnlock();</span><br><span class="line">        </span><br><span class="line">        <span class="type">RedissonMultiLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonRedLock</span>(lock1, lock2, lock3);</span><br><span class="line">        <span class="comment">// 给lock1，lock2，lock3加锁，如果没有手动解开的话，10秒钟后将会自动解开</span></span><br><span class="line">        lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        lock.unlock();</span><br><span class="line"></span><br><span class="line">        client1.shutdown();</span><br><span class="line">        client2.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-1-5-读写锁（ReadWriteLock）"><a href="#7-1-5-读写锁（ReadWriteLock）" class="headerlink" title="7.1.5 读写锁（ReadWriteLock）"></a>7.1.5 读写锁（ReadWriteLock）</h3><p>基于Redis的Redisson分布式可重入读写锁RReadWriteLock Java对象实现了java.util.concurrent.locks.ReadWriteLock接口。其中读锁和写锁都继承了RLock接口。</p>
<p>分布式可重入读写锁允许同时有多个读锁和一个写锁处于加锁状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">RReadWriteLock</span> <span class="variable">rwlock</span> <span class="operator">=</span> redisson.getReadWriteLock(<span class="string">&quot;anyRWLock&quot;</span>);</span><br><span class="line"><span class="comment">// 最常见的使用方法</span></span><br><span class="line">rwlock.readLock().lock();</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">rwlock.writeLock().lock();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// connects to 127.0.0.1:6379 by default</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">RReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getReadWriteLock(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">        lock.writeLock().tryLock();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                 <span class="type">RLock</span> <span class="variable">r</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">                 <span class="comment">// 10秒钟以后自动解锁，无需调用unlock方法手动解锁</span></span><br><span class="line">                 <span class="comment">//lock.readLock().lock(10, TimeUnit.SECONDS);</span></span><br><span class="line">                 r.lock();</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                r.unlock();</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line"></span><br><span class="line">        lock.writeLock().unlock();</span><br><span class="line"></span><br><span class="line">        t.join();</span><br><span class="line">        </span><br><span class="line">        redisson.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-1-6-信号量（Semaphore）"><a href="#7-1-6-信号量（Semaphore）" class="headerlink" title="7.1.6 信号量（Semaphore）"></a>7.1.6 信号量（Semaphore）</h3><p>基于Redis的Redisson的分布式信号量（Semaphore）Java对象RSemaphore采用了与java.util.concurrent.Semaphore相似的接口和用法。同时还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// connects to 127.0.0.1:6379 by default</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create();</span><br><span class="line"></span><br><span class="line">        <span class="type">RSemaphore</span> <span class="variable">s</span> <span class="operator">=</span> redisson.getSemaphore(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        s.trySetPermits(<span class="number">5</span>);</span><br><span class="line">        s.acquire(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">RSemaphore</span> <span class="variable">s</span> <span class="operator">=</span> redisson.getSemaphore(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">                s.release();</span><br><span class="line">                s.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">//或</span></span><br><span class="line">        s.acquire(<span class="number">4</span>);</span><br><span class="line">        </span><br><span class="line">        redisson.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-1-7-可过期性信号量（PermitExpirableSemaphore）"><a href="#7-1-7-可过期性信号量（PermitExpirableSemaphore）" class="headerlink" title="7.1.7 可过期性信号量（PermitExpirableSemaphore）"></a>7.1.7 可过期性信号量（PermitExpirableSemaphore）</h3><p>基于Redis的Redisson可过期性信号量（PermitExpirableSemaphore）是在RSemaphore对象的基础上，为每个信号增加了一个过期时间。每个信号可以通过独立的ID来辨识，释放时只能通过提交这个ID才能释放。它提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// connects to 127.0.0.1:6379 by default</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create();</span><br><span class="line"></span><br><span class="line">        <span class="type">RPermitExpirableSemaphore</span> <span class="variable">s</span> <span class="operator">=</span> redisson.getPermitExpirableSemaphore(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        s.trySetPermits(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获取一个信号，有效期只有2秒钟。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">permitId</span> <span class="operator">=</span> s.tryAcquire(<span class="number">100</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">RPermitExpirableSemaphore</span> <span class="variable">s</span> <span class="operator">=</span> redisson.getPermitExpirableSemaphore(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">permitId</span> <span class="operator">=</span> s.acquire();</span><br><span class="line">                    s.release(permitId);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line">        </span><br><span class="line">        s.tryRelease(permitId);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-1-8-闭锁（CountDownLatch）"><a href="#7-1-8-闭锁（CountDownLatch）" class="headerlink" title="7.1.8 闭锁（CountDownLatch）"></a>7.1.8 闭锁（CountDownLatch）</h3><p>基于Redisson的Redisson分布式闭锁（CountDownLatch）Java对象RCountDownLatch采用了与java.util.concurrent.CountDownLatch相似的接口和用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// connects to 127.0.0.1:6379 by default</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create();</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">RCountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> redisson.getCountDownLatch(<span class="string">&quot;latch1&quot;</span>);</span><br><span class="line">        latch.trySetCount(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 在其他线程或其他JVM里</span></span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    latch.await(<span class="number">550</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        executor.shutdown();</span><br><span class="line">        executor.awaitTermination(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-Zookeeper"><a href="#7-2-Zookeeper" class="headerlink" title="7.2 Zookeeper"></a>7.2 Zookeeper</h2><p>接着我们再看zookeeper的锁。zk不是为高可用性设计的，但它使用ZAB协议达到了极高的一致性。所以它经常被选作注册中心、配置中心、分布式锁等场景。它的性能是非常有限的，而且API并不是那么好用。xjjdog倾向于使用基于Raft协议的Etcd或者Consul，它们更加轻量级一些。我们看一下zk的加锁时序图。</p>
<p><img src="/2023/08/25/%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E9%94%81%E7%9A%84%E5%AD%A6%E4%B9%A0/image-20230904173348885.png" alt="image-20230904173348885"></p>
<p>﻿Curator是netflix公司开源的一套zookeeper客户端，目前是Apache的顶级项目。与Zookeeper提供的原生客户端相比，Curator的抽象层次更高，简化了Zookeeper客户端的开发量。Curator解决了很多zookeeper客户端非常底层的细节开发工作，包括连接重连、反复注册wathcer和NodeExistsException 异常等。Curator由一系列的模块构成，对于一般开发者而言，常用的是curator-framework和curator-recipes，我们跳过他的其他能力，直接看分布式锁。</p>
<h3 id="7-2-1-可重入锁（Shared-Reentrant-Lock）"><a href="#7-2-1-可重入锁（Shared-Reentrant-Lock）" class="headerlink" title="7.2.1 可重入锁（Shared Reentrant Lock）"></a>7.2.1 可重入锁（Shared Reentrant Lock）</h3><p>Shared意味着锁是全局可见的， 客户端都可以请求锁。Reentrant和JDK的ReentrantLock类似， 意味着同一个客户端在拥有锁的同时，可以多次获取，不会被阻塞。它是由类InterProcessMutex来实现。通过acquire获得锁，并提供超时机制。通过release()方法释放锁。InterProcessMutex 实例可以重用。Revoking ZooKeeper recipes wiki定义了可协商的撤销机制。为了撤销mutex, 调用makeRevocable方法。我们来看示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleClientThatLocks</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InterProcessMutex lock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FakeLimitedResource resource;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String clientName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleClientThatLocks</span><span class="params">(</span></span><br><span class="line"><span class="params">            CuratorFramework client, String lockPath, FakeLimitedResource resource, String clientName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resource = resource;</span><br><span class="line">        <span class="built_in">this</span>.clientName = clientName;</span><br><span class="line">        lock = <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(client, lockPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lock.acquire(time, unit)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(clientName + <span class="string">&quot; could not acquire the lock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(clientName + <span class="string">&quot; has the lock&quot;</span>);</span><br><span class="line">            resource.use();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(clientName + <span class="string">&quot; releasing the lock&quot;</span>);</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-2-不可重入锁（Shared-Lock）"><a href="#7-2-2-不可重入锁（Shared-Lock）" class="headerlink" title="7.2.2 不可重入锁（Shared Lock）"></a>7.2.2 不可重入锁（Shared Lock）</h3><p>使用InterProcessSemaphoreMutex，调用方法类似，区别在于该锁是不可重入的，在同一个线程中不可重入。</p>
<h3 id="7-2-3-可重入读写锁（Shared-Reentrant-Read-Write-Lock）"><a href="#7-2-3-可重入读写锁（Shared-Reentrant-Read-Write-Lock）" class="headerlink" title="7.2.3 可重入读写锁（Shared Reentrant Read Write Lock）"></a>7.2.3 可重入读写锁（Shared Reentrant Read Write Lock）</h3><p>类似JDK的ReentrantReadWriteLock. 一个读写锁管理一对相关的锁。一个负责读操作，另外一个负责写操作。读操作在写锁没被使用时可同时由多个进程使用，而写锁使用时不允许读 (阻塞)。此锁是可重入的。一个拥有写锁的线程可重入读锁，但是读锁却不能进入写锁。这也意味着写锁可以降级成读锁， 比如请求写锁 —&gt;读锁 —-&gt;释放写锁。从读锁升级成写锁是不成的。主要由两个类实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InterProcessReadWriteLock</span><br><span class="line">InterProcessLock</span><br></pre></td></tr></table></figure>

<h3 id="7-2-4-信号量（Shared-Semaphore）"><a href="#7-2-4-信号量（Shared-Semaphore）" class="headerlink" title="7.2.4 信号量（Shared Semaphore）"></a>7.2.4 信号量（Shared Semaphore）</h3><p>一个计数的信号量类似JDK的Semaphore。JDK中Semaphore维护的一组许可(permits)，而Cubator中称之为租约(Lease)。注意，所有的实例必须使用相同的numberOfLeases值。调用acquire会返回一个租约对象。客户端必须在finally中close这些租约对象，否则这些租约会丢失掉。但是， 但是，如果客户端session由于某种原因比如crash丢掉， 那么这些客户端持有的租约会自动close， 这样其它客户端可以继续使用这些租约。租约还可以通过下面的方式返还：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnAll</span><span class="params">(Collection&lt;Lease&gt; leases)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnLease</span><span class="params">(Lease lease)</span></span><br></pre></td></tr></table></figure>

<p>注意一次你可以请求多个租约，如果Semaphore当前的租约不够，则请求线程会被阻塞。同时还提供了超时的重载方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Lease <span class="title function_">acquire</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> Collection&lt;Lease&gt; <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> qty)</span></span><br><span class="line"><span class="keyword">public</span> Lease <span class="title function_">acquire</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span></span><br><span class="line"><span class="keyword">public</span> Collection&lt;Lease&gt; <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> qty, <span class="type">long</span> time, TimeUnit unit)</span></span><br></pre></td></tr></table></figure>

<p>主要类有:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InterProcessSemaphoreV2</span><br><span class="line">Lease</span><br><span class="line">SharedCountReader</span><br></pre></td></tr></table></figure>

<h3 id="7-2-5-多锁对象（Multi-Shared-Lock）"><a href="#7-2-5-多锁对象（Multi-Shared-Lock）" class="headerlink" title="7.2.5 多锁对象（Multi Shared Lock）"></a>7.2.5 多锁对象（Multi Shared Lock）</h3><p>Multi Shared Lock是一个锁的容器。当调用acquire， 所有的锁都会被acquire，如果请求失败，所有的锁都会被release。同样调用release时所有的锁都被release(失败被忽略)。基本上，它就是组锁的代表，在它上面的请求释放操作都会传递给它包含的所有的锁。主要涉及两个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InterProcessMultiLock</span><br><span class="line">InterProcessLock</span><br></pre></td></tr></table></figure>

<p>它的构造函数需要包含的锁的集合，或者一组ZooKeeper的path。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InterProcessMultiLock</span><span class="params">(List&lt;InterProcessLock&gt; locks)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InterProcessMultiLock</span><span class="params">(CuratorFramework client, List&lt;String&gt; paths)</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-6-完整锁示例"><a href="#7-2-6-完整锁示例" class="headerlink" title="7.2.6 完整锁示例"></a>7.2.6 完整锁示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockingExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QTY</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REPETITIONS</span> <span class="operator">=</span> QTY * <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PATH</span> <span class="operator">=</span> <span class="string">&quot;/examples/locks&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// FakeLimitedResource模拟一次只能由一个进程访问的某些外部资源</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">FakeLimitedResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FakeLimitedResource</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(QTY);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TestingServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestingServer</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">                Callable&lt;Void&gt; task = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Void <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(</span><br><span class="line">                                server.getConnectString(), <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            client.start();</span><br><span class="line"></span><br><span class="line">                            <span class="type">ExampleClientThatLocks</span> <span class="variable">example</span> <span class="operator">=</span></span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">ExampleClientThatLocks</span>(client, PATH, resource, <span class="string">&quot;Client &quot;</span> + index);</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; REPETITIONS; ++j) &#123;</span><br><span class="line">                                example.doWork(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            <span class="comment">// log or do something</span></span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            CloseableUtils.closeQuietly(client);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                service.submit(task);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            service.shutdown();</span><br><span class="line">            service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            CloseableUtils.closeQuietly(server);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h1><p>分布式环境中，我们始终绕不开CAP理论，这也是Redisson锁和ZK锁的本质区别。</p>
<p>CAP指的是在一个分布式系统中：</p>
<ul>
<li><p><strong>一致性（Consistency）</strong></p>
</li>
<li><p><strong>可用性（Availability）</strong></p>
</li>
<li><p><strong>分区容错性（Partition tolerance）</strong></p>
</li>
</ul>
<p>这三个要素<strong>最多只能同时实现两点，不可能三者兼顾。</strong>如果你的实际业务场景，更需要的是保证数据一致性。那么请使用CP类型的分布式锁，比如：zookeeper，它是基于磁盘的，性能可能没那么好，但数据一般不会丢。</p>
<p>如果你的实际业务场景，更需要的是保证数据高可用性。那么请使用AP类型的分布式锁，比如：Redisson，它是基于内存的，性能比较好，但有丢失数据的风险。</p>
<p>其实，在我们绝大多数分布式业务场景中，使用Redisson分布式锁就够了，真的别太较真。因为数据不一致问题，可以通过最终一致性方案解决。但如果系统不可用了，对用户来说是暴击一万点伤害。</p>
<h1 id="九、思考"><a href="#九、思考" class="headerlink" title="九、思考"></a>九、思考</h1><p>以上就是我对锁的总结。分布式锁不是完美的，总会有问题；如：在redis中，lockName和已有的key不能重名 ！unlock的前提是lock成功！必须要设计自己的兜底方案……</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">本文为个人知识学习，非原创！非作者！如本博客有侵权行为，请与我联系。</span><br><span class="line">摘录以下文章，内容根据个人需求有所删减，尊重知识产出，尊重作者知识劳动成果。</span><br><span class="line"></span><br><span class="line">作者：京东云开发者 管顺利</span><br><span class="line">链接：https://mp.weixin.qq.com/s/V2UPj1aQkDTydrIxYjg5Lw</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%94%81/" rel="tag"># 锁</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/08/09/%E6%96%B0%E4%B8%80%E4%BB%A3%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9F%A5%E8%AF%86%E5%85%85%E7%94%B5/" rel="prev" title="新一代微服务知识充电">
                  <i class="fa fa-angle-left"></i> 新一代微服务知识充电
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/10/16/2FA%E4%B8%8EMFA%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/" rel="next" title="2FA与MFA技术学习">
                  2FA与MFA技术学习 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">BigOrange</span>
  </div><div>
  <a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral">
  本网站由
  <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlIAAAEuCAMAAAByCQxmAAAABlBMVEUAoP8AoP+IQHPMAAAAAnRSTlML9sG5Q9oAAAfGSURBVHja7d3RbuM4EETR7v//6cUA+7DAJGuLrOpuUve+zsSU6GNKlhwngoiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIhmlv/GTJBG0t8xNyTDBCwycYIVGTjBihyeMEVqT5gitSdIkRoUpEgMClIkBgUpEoNCFGlB5Q+PyuwCSkSKhQtQ4kWKoyGibKJABSi5KEwhSnYiBSpAeRYpTCFKLwpTiFKLAhWghCdSmEKUZZHCFKLkojCFKLUoUCFKeCKFKURZFilMIUouClOIUovCFKKEJ1KYQpRjkcIUouSiMIUotShMIUp4IgUpRDkWKUwhSi0KU5BSi8IUooQnUphClGORghSi1KIwBSm1qENNPdn4S19Vc0UdOaNPNv7SV5VZFKQgJf4Sqdd9JRWkzN9G9r6vOWsm1T/bRk2ah5+w9J5DKge8hM1bkE37mH2mOknlAFLm4bNpHxNSXaTMgzccdiB1LqnCJ/ZeUupLnf2kvAMnpA58+960BdXPKqROIXXAMQ9SbyBVeWdniqlTSHVflxIOmeZOutbZe+H/wEWqntOEF/w5pI67udcEqv0FDykXqS5Q7csUpEyk+kBB6hWiMl9DqkLiG0m1iuq9yFNxVv96UZnXk1ob+/NWH/c2pYZU5v2mvh364Q4c+NbXRKpdFKSGkzpP1FRST/cAUmNElc+mepGC1K87kqeR2r7xrJrKq0mdKGrz9xogNYmUS1QUfCfs8k8nB74aUoYlxzqdKSAVrFJniQrvX21Y/enUkwpIGUmtbc9MUrFO6qJ7PMNEOU2t/rTg5z7ejyk4fE8nZXzrNpjUxtyqHng+qeZFKg4gtTHoh5+EVM0i9eWD151MQcpHKiaRqlumIFVBynsRfBapnSEhBSlIHS6qmlRAClI2UlnyFEIKUpCqJGUQtfetCiVHvoQUpLRPiOr9AKQ6SSWk3kbK/fHMmk92Pv/+PkidQWrj6zqKScV4UmnuiOPe1rwUkMqDSKW/Q0itz0z4TekAX0EqTyGVY0klpEpIeTc13aQWP/YbkEr1H+HwbnrdKrX4ywmQghSkIDXuyCcdClKQghSk1Ka0I73luhSkLiI14+r5S0l9ZUo80IR7fLoJhBSkfprb7pvG6V1fCy8ifPe8aAb68CArY8hIDfogwmWk0jj5nx5lYZBUkYpJpMJJKktIxRNShgnVTOTERWr5CbyJVNaLavp+qQpR60eZ00lFM6mOb8HL2aTiIlLZIKqbVES7qb13i8OuIXya4PVRJpPK8aTiWlKqp20wqegnFVWksoxUfPXew/tup5JUlait38I8nFR8c4nkGlI5jFSYScUgUrorP2NJBaQ8on6ZZtnl6VHXpfJlpHoWqZ/n2fQG4It3zVYadaK2vmr1eFLxYd3wLIMdt40TUkWk/nrOjWb//5+jjlS8gNTiI9r3Xvr40UmqVNTOydQFpKKMLKQKL3UuPqR7/+MeUrWiNkzdsEj9PmjcQypPIdW8SEFq7t9ba/5wy/JDeicg7iGVU0m5fg+xe5H6edy4lFTEWFN5zyIVzt9vG0CqQdTCJzuzX5SVVECqipS8GLFIXU2qQ1ScKMpLKt9NKg82NYRUXkzq+V7JP4qGqKsuIjzeJ9H+94OKbCPlHWESqUcPfuIytbcBBSeSN5DK9ROv80jFjEWq7sMzLyMVh4nKClEXfF5q62PIZ5HaHr3q8snbSB175Bsi6qeHVY/USmrlktSRpgRDGy+Zi4c6jdSJy1TMFqU21UlqaS+OW6Y043pvwUiHayS1uA9HkVKN6r6ppxxwCKnFqRltSjmm/56ebkgrKQ+NwaRcQxquHDxbxd5DapIp53juJerB/+ogtXDcW5+hMaRirqidY/LecMWkUkJqiinvWOo93NdXSiqfk5JvdTkp70hVoDSm5KTSf9ybt0yZh9HunNbg8+d14xbc16QMx+taUuYxCkHto0o1qaWXw+Zs9ZsyD6DcrfUflS0pOxvjXGgmfW6qeQ18MOzez4uWlI0z0Cgi1b1MmS9PCPfHbjKfkXp8xmBFkWOWKfctHtmuuBe6b//n+gJvVWG+trz6lGejKPnhc/dWuHy6S2+GNJo6Q5R4WrbOvGZe+yu4qzpDlIiUel62LlZMvONV8tGPw0S5fjfvi4eseRc886atl1SvqCh9tanv+ehmYs4qFSMXKfFyopubrbdmXat1Nak4+7Bn/aLED++w9y5elV5HqSUVZ4syfgPZp0s+7jueQz8IYNmUSaIqvkL3K1LqeR5529a1IYNOpP67CWHs5xG2bi17ntgZonZePgNE/dmIKOjX30uMYQ0AFet/zWWEKBrZmBMpnor3mfIuUjwR7zOFKNKaQhSJTSGKtKasixRPwAtNIYq0qBBFYlOIIq0p5yLFvL/RlFEUk/5KVIgisSlEkdaUbZFisl+KClGkNeUSxTS/FpVHFFP8XlSeRYr5fS2qsIhibkkqipkkKSnmkaSimEaSkmISSUmKGSSpKaaPlKaYOhKiYtJIyIrJIp0rpohUspgUIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiOqZ/AMg6kmnDoZrIAAAAAElFTkSuQmCC" width="45px" style="display:inline;padding-top:5px;"/>
  提供CDN加速/云存储服务
  </a>
  <a>&emsp;|&emsp;</a>
  <a href="https://www.foreverblog.cn/" target="_blank" ><img src="https://img.foreverblog.cn/logo_en_default.png" alt="" style="display:inline;height:16px;"></a>
</div>
<script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js?id=3HGFkqwJpvEGaeV9&ck=3HGFkqwJpvEGaeV9&autoTrack=true"></script>
<script defer src="https://cloud.umami.is/script.js" data-website-id="4d271e0d-e852-48ab-9777-6a09832bf70e"></script>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"BaseOrange","repo":"BaseOrange.github.io","client_id":"8f8eb36a78230e56ee7e","client_secret":"c826afd9bd0b45f07426463094a3ad186de52bd8","admin_user":"BaseOrange","distraction_free_mode":true,"proxy":"https://proxy.660066.xyz/github_access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"c10c8ef0b0f7fe517953e553b075dc8a"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
